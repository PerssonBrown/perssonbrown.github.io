{"posts":[{"title":"KMP 算法","text":"KMP 算法是一个字符串匹配算法。 但在学习 KMP 字符串匹配算法前，我们先介绍前缀函数概念。 前缀函数给定一个长度为 $n$ 的字符串 $S$，其前缀函数为一个长度为 $n$ 的数组 $\\pi$。 $\\pi[i]$ 的定义为：子串 $S[0\\dots i]$ 最长的相等的真前缀与真后缀的长度。规定：$\\pi[0]=0$。 以字符串 abcabcd 为例。 $\\pi[0]=0$，此时的子串为 a； $\\pi[1]=0$，此时的子串为 ab； $\\pi[2]=0$，此时的子串为 abc； $\\pi[3]=1$，此时的子串为 abca； $\\pi[4]=2$，此时的子串为 abcab； $\\pi[5]=3$，此时的子串为 abcabc； $\\pi[6]=0$，此时的子串为 abcabcd。 如何计算前缀函数问题：现有一个字符串 $S$，现在要在其后追加一个字符 $x$。 以下图为例，已知 $\\pi[0\\dots i]$ 如何计算 $\\pi[i+1]$？ $\\overbrace{\\underbrace{S_0~S_1}_j~S_2~S_3}^{\\pi[i]}~\\dots~\\overbrace{S_{i-3}~S_{i-2}~\\underbrace{S_{i-1}~S_{i}}_j}^{\\pi[i]}~S_{i+1}$ 要找 $\\pi[i+1]$ 就是要找到 $S[0\\dots j+1]=S[i-j \\dots i+1]$ $(j\\leq\\pi[i])$。其中 $j$ 是前缀的长度。 因为 $S[0\\dots \\pi[i]-1]=S[i-\\pi[i]+1\\dots i]$。问题就转化成了在一个长为 $m(m=\\pi[i])$ 的字符串后追加一个字符 $x$，求 $\\pi[m+1]$。这样一来该问题就可以递推求解。 下面给出示例代码。 123456pi[0] = 0;for (int i = 1; i &lt; n; i++) { int j = pi[i - 1]; while (j &gt; 0 &amp;&amp; s[i] != s[j]) j = pi[j - 1]; pi[i] = j + (s[i] == s[j]);} 该方法的时间复杂度为 $O(n)$。 KMP 算法问题：现有一个字符串 $S$，要在其中找到字符串 $P$。 使用暴力进行匹配是可行的，复杂度为 $O(mn)$，其中 $m$ 和 $n$ 是字符串 $S$ 和 $P$ 长度。 设 $i$ 为指向 $S$ 字符串的指针，$j$ 为指向 $P$ 字符串的指针。 在暴力算法中，当 $S[i+j-1]\\neq P[j]$ 时，我们会这样做：++i 和 j=0 然而 $S[i\\dots i+j-2]$ 必然是 $P[0\\dots j-1]$ 相等的，那么能否从这一点中优化呢？ 观察下面这个例子，此时 $S[i+j-1]\\neq P[j]$。 1234 i S: abcabf...P: abcaba j 按照暴力的代码，它将会变成这样： 1234 iS: abcabf...P: abcaba j 设 $Q=S[i\\dots i+j-2]=P[0\\dots j-1]$，$Q$ 应当是有一部分等长的前缀和后缀相等（可能为 $0$）。利用这一点，我们为何不可以将其变成这样： 1234 i S: abcabf...P: abcaba j 应当是有一部分等长的前缀和后缀相等 这个长度就可以用上文提到的前缀函数来计算。 到此，KMP 算法的代码就呼之欲出了。下面给出示例代码。 1234567891011121314int i = 0, j = 0;while (i &lt; s.length()) { if (s[i] == p[j]) { ++i; ++j; } else if (j &gt; 0) { j = pi[j - 1]; } else { ++i; } if (j == p.length()) { ans.push_back(i - p.length() + 1); }}","link":"/article/kmp/"},{"title":"USACO12-FEB Cow IDs 题解","text":"USACO12-FEB Cow IDs 题解 题目要求输出第 $n$ 小的二进制中包含 $k$ 个 $1$ 的数字。 数据范围： $1\\leq n\\leq 10^7, 1\\leq k\\leq 10$。 例如：当 $n=7,k=3$ 应当输出 10110。 暴力求解很容易想到从 $1$ 循环到 $\\infty$，如果 $i$ 在二进制下有 $k$ 个数字，计数器 cnt 自加。直到 cnt == n，输出此时的 $i$ 并退出。 下面是该思路下的代码： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;int func(int n) { int a = 0; while (n) { if (n &amp; 1) { ++a; } n &gt;&gt;= 1; } return a;}int arr[1000];int main() { int i, n, k, cnt = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (i = 0; cnt != n; ++i) { cnt += (func(i) == k); } --i; cnt = 0; while (i) { arr[cnt++] = (i &amp; 1); i &gt;&gt;= 1; } for (int i = cnt - 1; i &gt;= 0; --i) { printf(&quot;%d&quot;, arr[i]); } puts(&quot;&quot;); return 0;} 当 $i\\geq 10^7$ 时，该程序就显得力不从心了。 组合数学观察符合条件的数字的二进制，这里截取了 $k=3$ 时的部分数据： 123456781 1 1 01 0 0 1 1 1 0 1 0 1 1 0 1 1 0 1 1 0 0 1 1 1 0 1 0 1 1 1 0 0 1 0 0 0 1 1 不难发现，这其实是按字典序排列的数组全排列。下面以 $k=3$ 为例的表格，第一行表示以该序列为起点向后能有几个全排列。 111 1011 10011 10011 … $n$ 1 3 6 10 … $C_{n+3-2}^{3-1}$ 当 $k$ 为其他数值时，第 $n$ 个的数值应该为 $C_{n+k-1}^{k-1}$。 依次存储 $C_{i+k-1}^{k-1}$，之后求前缀和。当 $\\texttt{pre[i]}\\geq n$，说明要找的那个序列就在第 $i$ 组之中。从该组的 10...01...1 向后不断求下一个排列，直到刚好到 $n$ 为止。输出那个排列，返回。 下面给出该方法的代码（使用到了 algorithm 库里的 std::next_permutation 函数求下一个排列）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;algorithm&gt;typedef unsigned long long ull;ull arr[100000], pre[100000];ull C(ull n, ull m) { if (m == 0 || m == n) { return 1; } return C(n - 1, m - 1) + C(n - 1, m);}int main() { ull n, k, p; scanf(&quot;%llu%llu&quot;, &amp;n, &amp;k); if (k == 1) { printf(&quot;1&quot;); for (ull i = 2; i &lt;= n; ++i) { printf(&quot;0&quot;); } puts(&quot;&quot;); return 0; } for (ull i = 1; true; ++i) { pre[i] = pre[i - 1] + C(i + k - 2, k - 1); if (pre[i] &gt;= n) { p = i; break; } } for (ull i = 1; i &lt;= k + p - 1; ++i) { arr[i] = 1; } for (ull i = 2; i &lt;= p; ++i) { arr[i] = 0; } ull step = n - pre[p - 1] - 1; while (step &gt; 0 &amp;&amp; std::next_permutation(arr + 1, arr + k + p)) { --step; } for (ull i = 1; i &lt;= k + p - 1; ++i) { printf(&quot;%llu&quot;, arr[i]); } puts(&quot;&quot;); return 0;} 其他方法以 $k=3$ 为例，这里截取部分输出（为方便观察，* 表示 $1$，. 表示 $0$） 123456789101112131415161718192021222324252627282930313233343536*.......***......*.**......**.*.....*..**.....*.*.*.....**..*....*...**....*..*.*....*.*..*....**...*...*....**...*...*.*...*..*..*...*.*...*...**....*..*.....**..*....*.*..*...*..*..*..*...*..*.*....*..**.....*.*......**.*.....*.*.*....*..*.*...*...*.*..*....*.*.*.....*.**......**.......***......*.**.....*..**....*...**...*....**..*.....**.*......***....... 观察 * 的分布，你会发现其呈现的是一个分形的图案，利用这一点即可计算出第 $n$ 个的 * 该如何排列。 本人未实现该方法的代码，如有能力者可自行实现。思路提供者：Rickyxrc","link":"/article/solution-CowIDs/"}],"tags":[{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"string","slug":"string","link":"/tags/string/"},{"name":"oi","slug":"oi","link":"/tags/oi/"},{"name":"solution","slug":"solution","link":"/tags/solution/"},{"name":"usaco","slug":"usaco","link":"/tags/usaco/"}],"categories":[],"pages":[]}