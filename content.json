{"posts":[{"title":"KMP 算法","text":"KMP 算法是一个字符串匹配算法。 但在学习 KMP 字符串匹配算法前，我们先介绍前缀函数概念。 前缀函数给定一个长度为 $n$ 的字符串 $S$，其前缀函数为一个长度为 $n$ 的数组 $\\pi$。 $\\pi[i]$ 的定义为：子串 $S[0\\dots i]$ 最长的相等的真前缀与真后缀的长度。规定：$\\pi[0]=0$。 以字符串 abcabcd 为例。 $\\pi[0]=0$，此时的子串为 a； $\\pi[1]=0$，此时的子串为 ab； $\\pi[2]=0$，此时的子串为 abc； $\\pi[3]=1$，此时的子串为 abca； $\\pi[4]=2$，此时的子串为 abcab； $\\pi[5]=3$，此时的子串为 abcabc； $\\pi[6]=0$，此时的子串为 abcabcd。 如何计算前缀函数问题：现有一个字符串 $S$，现在要在其后追加一个字符 $x$。 以下图为例，已知 $\\pi[0\\dots i]$ 如何计算 $\\pi[i+1]$？ $\\overbrace{\\underbrace{S_0~S_1}_j~S_2~S_3}^{\\pi[i]}~\\dots~\\overbrace{S_{i-3}~S_{i-2}~\\underbrace{S_{i-1}~S_{i}}_j}^{\\pi[i]}~S_{i+1}$ 要找 $\\pi[i+1]$ 就是要找到 $S[0\\dots j+1]=S[i-j \\dots i+1]$ $(j\\leq\\pi[i])$。其中 $j$ 是前缀的长度。 因为 $S[0\\dots \\pi[i]-1]=S[i-\\pi[i]+1\\dots i]$。问题就转化成了在一个长为 $m(m=\\pi[i])$ 的字符串后追加一个字符 $x$，求 $\\pi[m+1]$。这样一来该问题就可以递推求解。 下面给出示例代码。 123456pi[0] = 0;for (int i = 1; i &lt; n; i++) { int j = pi[i - 1]; while (j &gt; 0 &amp;&amp; s[i] != s[j]) j = pi[j - 1]; pi[i] = j + (s[i] == s[j]);} 该方法的时间复杂度为 $O(n)$。 KMP 算法问题：现有一个字符串 $S$，要在其中找到字符串 $P$。 使用暴力进行匹配是可行的，复杂度为 $O(mn)$，其中 $m$ 和 $n$ 是字符串 $S$ 和 $P$ 长度。 设 $i$ 为指向 $S$ 字符串的指针，$j$ 为指向 $P$ 字符串的指针。 在暴力算法中，当 $S[i+j-1]\\neq P[j]$ 时，我们会这样做：++i 和 j=0 然而 $S[i\\dots i+j-2]$ 必然是 $P[0\\dots j-1]$ 相等的，那么能否从这一点中优化呢？ 观察下面这个例子，此时 $S[i+j-1]\\neq P[j]$。 1234 i S: abcabf...P: abcaba j 按照暴力的代码，它将会变成这样： 1234 iS: abcabf...P: abcaba j 设 $Q=S[i\\dots i+j-2]=P[0\\dots j-1]$，$Q$ 应当是有一部分等长的前缀和后缀相等（可能为 $0$）。利用这一点，我们为何不可以将其变成这样： 1234 i S: abcabf...P: abcaba j 应当是有一部分等长的前缀和后缀相等 这个长度就可以用上文提到的前缀函数来计算。 到此，KMP 算法的代码就呼之欲出了。下面给出示例代码。 1234567891011121314int i = 0, j = 0;while (i &lt; s.length()) { if (s[i] == p[j]) { ++i; ++j; } else if (j &gt; 0) { j = pi[j - 1]; } else { ++i; } if (j == p.length()) { ans.push_back(i - p.length() + 1); }}","link":"/article/kmp/"}],"tags":[{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"string","slug":"string","link":"/tags/string/"}],"categories":[],"pages":[]}