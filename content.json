{"posts":[{"title":"kmp","text":"KMP 算法是一个字符串匹配算法。 在学习 KMP 字符串匹配算法前，我们先介绍前缀函数概念。 前缀函数给定一个长度为 $n$ 的字符串 $S$，其前缀函数为一个长度为 $n$ 的数组 $\\pi$。 $\\pi[i]$ 的定义为：子串 $S[0\\dots i]$ 最长的相等的真前缀与真后缀的长度。规定：$\\pi[0]=0$。 以字符串 abcabcd 为例。 $\\pi[0]=0$，此时的子串为 a； $\\pi[1]=0$，此时的子串为 ab； $\\pi[2]=0$，此时的子串为 abc； $\\pi[3]=1$，此时的子串为 abca； $\\pi[4]=2$，此时的子串为 abcab； $\\pi[5]=3$，此时的子串为 abcabc； $\\pi[6]=0$，此时的子串为 abcabcd。 如何计算前缀函数问题：现有一个字符串 $S$，现在要在其后追加一个字符 $x$。 以下图为例，已知 $\\pi[0\\dots i]$ 如何计算 $\\pi[i+1]$？ $$\\overbrace{\\underbrace{S_0 ~ S_1}j ~ S_2 ~ S_3}^{\\pi[i]} ~ \\dots ~ \\overbrace{S{i-3} ~ S_{i-2} ~ \\underbrace{S_{i-1} ~ S_{i}}j}^{\\pi[i]} ~ S{i+1}$$ 要找 $\\pi[i+1]$ 就是要找到 $S[0\\dots j+1]=S[i-j\\dots i+1](j\\leq \\pi[i])$。$j$ 是前缀的长度。 因为 $S[0\\dots \\pi[i]-1]=S[i-\\pi[i]+1\\dots i]$。问题就转化成了在一个长为 $m(m=\\pi[i])$ 的字符串后追加一个字符 $x$，求 $\\pi[m+1]$。这样一来该问题就可以递推求解。 下面给出代码。 12345pi[0] = 0;for (int i = 1; i &lt; n; i++) { int j = pi[i - 1]; while (j &gt; 0 &amp;&amp; s[i] != s[j]) j = pi[j - 1]; pi[i] = j + (s[i] == s[j]);","link":"/article/kmp/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"string","slug":"string","link":"/tags/string/"}],"categories":[],"pages":[]}